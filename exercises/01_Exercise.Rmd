---
title: "Workflow of pharmacokinetic modeling (model construction + data manipulation + visualization)"
author: "Nan-Hung Hsieh"
date: "2019/12/09 (update: `r Sys.Date()`)"
output: 
  html_document:
    toc: true
    toc_depth: 2
    number_sections: false
  fig_caption: yes  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd('..')
wd <- getwd()
knitr::opts_knit$set(root.dir =  wd)
```

## 0 Prerequisites

Import the R packages

```{R message=FALSE, warning=FALSE}
library(simuloR)
library(httk)
library(deSolve)
library(tidyverse)
theme_set(theme_bw())
```

## Task 1: Exploratory data analysis

- Now, we have a theophylline PK dataset. The purpose of this exercise is to develop the simple PK model and use it to describe the PK of theophylline. First, look into the theophylline dataset. The `Theoph` data frame has 132 rows and 5 columns of data from an experiment on the pharmacokinetics of theophylline. Then, find the Cmax and Tmax for each individual. 



```{r}
head(Theoph)
```


```{r}
tail(Theoph)
```


```{r}
subset(Theoph, Subject == 1)
```


```{r}
subset(Theoph, Subject == 1) %>% summary()
```


```{r}
s1 <- subset(Theoph, Subject == 1) 
plot(s1$Time, s1$conc)
```


```{r}
plot(Theoph$Time, Theoph$conc, col=Theoph$Subject)
```


```{r}
par(mfrow=c(3,4))
for(i in 1:12){
  dat <- subset(Theoph, Subject == i)  
  plot(dat$Time, dat$conc, main = i)
}
```

```{r}
Theoph %>% ggplot(aes(x = Time, y =conc, color = Subject)) + 
  geom_point()
```

```{r}
Theoph %>% ggplot(aes(x = Time, y =conc, color = Subject)) + 
  geom_point() + geom_line() + 
  labs(x = "Time (hr)", y = "Concentration (mg/L)")
```

```{r}
Theoph %>% ggplot(aes(x = Time, y =conc)) + 
  geom_point() + geom_line() + 
  facet_wrap(~Subject) + 
  labs(x = "Time (hr)", y = "Concentration (mg/L)")
```


```{r}
class(Theoph$Subject)
```

```{r}
Theoph$Subject
```

```{r}
Theoph$Subject <- factor(Theoph$Subject, 
                            level = c("1", "2", "3", "4", "5", "6", 
                                      "7", "8", "9", "10", "11","12"))
```


```{r}
Theoph$Subject
```


```{r}
Theoph %>% ggplot(aes(x = Time, y =conc)) + 
  geom_point() + geom_line() + 
  facet_wrap(~Subject) + 
  labs(x = "Time (hr)", y = "Concentration (mg/L)")
```


```{r}
s1.Cmax <- max(s1$conc)
s1.Cmax
```


```{r}
which(s1$conc == s1.Cmax)
```


```{r}
t.pt <- which(s1$conc == s1.Cmax)
T_max <- s1$Time[t.pt]
```





```{r}
Cmax_pop <- Theoph %>% group_by(Subject) %>% summarise(C_max = max(conc))
Cmax_pop
```


```{r}
hist(Cmax_pop$C_max)
```


```{r}
boxplot(Cmax_pop$C_max)
```


```{r}
Theoph %>% group_by(Subject) %>% summarise(C_max = max(conc), Wt=mean(Wt))
```

```{r}
Theoph %>% group_by(Subject) %>% 
  summarise(C_max = max(conc), Wt=mean(Wt)) %>% 
  ggplot(aes(x=Wt, y=C_max)) + geom_point()
```


```{r}
Theoph %>% group_by(Subject) %>% 
  summarise(C_max = max(conc), Wt=mean(Wt)) %>% 
  ggplot(aes(x=Wt, y=C_max)) + geom_point() + geom_smooth(method = "lm")
```


```{r}
df <- Theoph %>% group_by(Subject) %>% summarize(C_max = max(conc))
df$T_max <- NA
df
```


```{r}
dat <- subset(Theoph, Subject==1)
C_max.pt <- which(dat$conc == df$C_max[1])
df$T_max[1] <- dat$Time[C_max.pt]
df
```


```{r}
for(i in 2:12){
  dat <- subset(Theoph, Subject==i)
  C_max.pt <- which(dat$conc == df$C_max[i])
  df$T_max[i] <- dat$Time[C_max.pt]
}
df
```


## Task 2: Model development

- Develop the non compartment model and compartment model in R and MCSim

**The MCSim Syntax of the model description file**

```r
# Model description file (this is a comment)

<Global variable specifications>

States = { 
  <state variables for the model, such as quantity> 
}
Outputs = { 
  <output variables, such as concentration> 
}
Inputs = { 
  <input variables, such as exposure dose>
}
Initialize {
  <Equations for initializing or scaling model parameters>
}
Dynamics {
  <Equations for computing derivatives of the state variables>
}
CalcOutputs {
  <Equations for computing output variables>
}
End. # mandatory ending keyword
```

**General syntax **

Variable assignments 

```r
<variable-name> = <constant-value-or-expression> ;
```

Colon conditional assignments 

```r
<variable-name> = (<test> ? <value-if-true> : <value-if-false>);
```

For example

```r
Adjusted_param = (Input_var > 0.0 ? Param * 1.1 : Param);
```


**Syntax of (simulation) input-file**

For the basic simulation 

```r
# Input-file (text after # are comments)
<Global assignments and specifications>
Simulation {
  <Specifications for first simulation>
}
Simulation {
  <Specifications for second simulation>
}
# Unlimited number of simulation specifications
End. # Mandatory End keyword. Everything after this line is ignored
```

### 1.1 Define the state variables [`States{}`](https://www.gnu.org/software/mcsim/mcsim.html#Global-variable-declarations)

States are variables for which a first-order differential equation is defined in the `Dynamics{}` section. Remember, when naming the variables, be sure to let all variable names begin with a capital letter followed by meaningful lower case subscripts. In `States{}` section, each variable needs to separate by comma `,`. In addition, remember to provide the unit that is used for the state variables. 

### 1.2 Define the outputs variables [`Outputs{}`](https://www.gnu.org/software/mcsim/mcsim.html#Global-variable-declarations)

Outputs are dependent model variables (obtainable at any time as analytical functions of the states, inputs or parameters) that do not have dynamics. They must receive assignments in either the `Dynamics` or `CalcOutputs` sections. When constructing the model, we need to have an output variable for checking mass balance. Then, assign the variable that we are interested in or have an experiment to make the comparison, such as the blood concentration.

### 1.3 Define the input variable(s) [`Inputs{}`](https://www.gnu.org/software/mcsim/mcsim.html#Global-variable-declarations)

Inputs are variables independent of the other variables, but eventually varying with time (for example an exposure concentration to a chemical). *GNU MCSim* has various functions to define the different exposure types as:

- PerDose(): # specifies a periodic input of constant

    `PerDose(<magnitude>, <period>, <initial-time>, <exposure-time>);`

- PerExp(): # specifies a periodic exponential input.

    `PerExp(<magnitude>, <period>, <initial-time>, <decay-constant>);`

- PerTransit(): #models a delayed input mechanism (e.g., gut absorption) 

    `PerTransit(<magnitude>, <period>, <initial-time-in-period>, <decay-constant>, <number-of-input-compartments>);`  
    
- NDoses(): # specifies a number of stepwise inputs of variable magnitude and their starting times
    
    `NDoses(<n>, <list-of-magnitudes>, <list-of-initial-times>);`

- Spikes(): # specifies a number of instantaneous inputs of variable magnitude and their exact times of occurrence.
    
    `Spikes(<n>, <list-of-magnitudes>, <list-of-times>);`

### 1.4 Parameters of the model

Here we need to define the "default" value of input parameters. Unlike previous variables that need to use curly brackets to group these variables, the input parameters can be put in any places without the restriction. In addition, don't forget to put a semicolon (`;`) after the definition of each parameter. If the input parameter doesn't have a default value, just put a semicolon after the name of the parameter or used an arbitrary number. 

The PBPK parameters always include the parameters that can describe absorption, distribution (e.g., partition coefficient), metabolism (e.g., Michaelis-Menten constant), and elimination (e.g., rate Constant). These parameters can be classified to chemical-specific (e.g., molecular weight) and anatomy (e.g., body weight, blood flow, tissue weight/volume) parameter. In addition, the unit conversion factor can define in this part. 

The parameters of the PBPK model might include: 

- Unit conversion factor 

- Exposure modeling parameters

- Chemical-specific parameters

- Physiological parameters

- Pharmacokinetic parameters

- Scale parameters (no default value)

### 1.5 Define the parameter initialization and scaling [`Initialize{}`](https://www.gnu.org/software/mcsim/mcsim.html#Model-initialization)

This section is used to scale specific model parameters and resolve dependencies between parameters. Generally, the scaling involves a change of units or conversion from percentage to actual units.

### 1.6 Define the dynamics of the simulation [`Dynamics{}`](https://www.gnu.org/software/mcsim/mcsim.html#Dynamics-section)

The equations given in this section will be called by the integration routines at each integration step. It includes specification of differential equations.

The derivative of a state variable is defined using the `dt()` operator, as shown here:

`dt(state-variable) '=' constant-value-or-expression ';'`

### 1.7 Define the output calculations [`CalcOutputs{}`](https://www.gnu.org/software/mcsim/mcsim.html#Output-calculations) 

In this section, the equations are given in this section will be called by the simulation program at each output time specified by a `Print()` or `PrintStep()` statement. In this way, output computations are done efficiently, only when values are to be saved. Here is the example to assign the variables in `CalcOutputs{}` section. Again, don't forget the semicolon and put the keyword `End.` at the end of model. 

Same as model file, we highly recommend to use comments (`#`) to annotate your code in the beginning. This comment might include:

- Brief description of this input file
- What model file that is used to conduct the simulation
- Others...

### 1.8 Setting integrator [`Integrate()`](https://www.gnu.org/software/mcsim/mcsim.html#Integrate_0028_0029-specification)

*GNU MCSim* provides three types of integrator that include `Lsodes`, `Cvodes`, and `Euler`. Here, we used `Lsodes` (Livermore Solver for Ordinary Differential Equation) as a primary solver, which was originated from the SLAC Fortran library. The `Lsodes` function uses adaptive numerical methods to advance a solution to a system of ordinary differential equations one time-step, given values for the variables Y and X. It solves the initial value problem for stiff or non-stiff systems of ordinary differential equations (ODE).

The syntax for `Lsodes` is: `Integrate(Lsodes, <rtol>, <atol>, <method>);`

where `<rtol>` is a scalar specifying the relative error tolerance for each integration step. The scalar `<atol>` specifies the absolute error tolerance parameter. Those tolerances are used for all state variables. The estimated local error for a state variable y is controlled so as to be roughly less (in magnitude) than rtol*|y| + atol. Thus the local error test passes if, for each state variable, either the absolute error is less than <atol>, or the relative error is less than `<rtol>`. Set `<rtol>` to zero for pure absolute error control, and set `<atol>` to zero for pure relative error control. Caution: actual (global) errors may exceed these local tolerances, so choose them conservatively. Decreasing the tolerance leads to more accurate results but at the cost of significant increase in time taken.

The `<method>` flag should be 0 (zero) for non-stiff differential systems and 1 or 2 for stiff systems. You should try flag 0 or 1 and select the fastest for equal accuracy of output unless insight from your system leads you to choose one of them a priori. If you specify <method> 2 you should provide the Jacobian of your differential system. The good starting point for <atol> and <rtol> is about 1e-6. The default integration method in `Lsodes` with parameters 1e-5, 1e-7 and 1.

### 1.9 Setting paramerer(s)

For the simple simulation, we can assign the given parameter values in the input file to replace the default values in the model file. The parameter can be set in the `simulation{}` section as a local setting or outside the section as a global setting. Same as the parameter setting in the model file, use `=` to define the given value of parameters and put `;` after the definition.


**Input functions**

These functions can use to different exposure types

```r
- PerDose(): # specifies a periodic input of constant

    PerDose(<magnitude>, <period>, <initial-time>, <exposure-time>);

  
- PerExp(): # specifies a periodic exponential input.

    PerExp(<magnitude>, <period>, <initial-time>, <decay-constant>);  

  
- PerTransit(): models a delayed input mechanism  

    PerTransit(<magnitude>, <period>, <initial-time-in-period>, 
              <decay-constant>, <number-of-input-compartments>);  
    
              
- NDoses(): specifies a number of stepwise inputs of variable magnitude and their starting times
    
    NDoses(<n>, <list-of-magnitudes>, <list-of-initial-times>);


- Spikes(): specifies a number of instantaneous inputs of variable magnitude and their exact times of occurrence.
    
    Spikes(<n>, <list-of-magnitudes>, <list-of-times>);

```

### 1.10 Setting simulation [`simulation{}`]()

After the global specifications, we can define the local parameters. In addition, we need to define the output through [Print()](https://www.gnu.org/software/mcsim/mcsim.html#Print_0028_0029-specification) or [PrintStep()](https://www.gnu.org/software/mcsim/mcsim.html#PrintStep_0028_0029-specification) functions. The arguments of `Print()` and `PrintStep()` are the comma-separated list of variable names (at least one and up to MAX_PRINT_VARS, which is set to 10 by default) and followed by given time-points (limited by the available memory at run time) as:

`Print(<identifier1>, <identifier2>, ..., <time1>, <time2>, ...);`

`PrintStep(<identifier1>, <identifier2>, ..., <start-time>, <end-time>, <time-step>);`

**Note:** The output variables cannot receive assignments in simulation input files.




- Non compartment model

$$C(t) = \frac{F\cdot D \cdot ka}{V(k_a - k_e)}\cdot(\mathrm{e}^{-k_et}-\mathrm{e}^{-k_a{t}})$$

- Compartment model

$$\frac{dA_{gut}}{dt}=-k_aA_{gut}$$

$$\frac{dA}{dt}=k_aA_{gut}-k_eA_e$$
$$C=A/V$$


- Non compartment model (R)

```{r}
ffpk <- function(D, Fa, ka, ke, V, t){
    MW <- 180.167
    A <- (D * Fa * ka)/(V * (ka - ke))
    C <- A * exp(-ke * t) - A * exp(-ka * t)
    #C_uM <- C/MW*1000
    return(C)
}
```

- Non compartment model (MCSim)

```r
Outputs = {
  A,
  Conc,
  C_rest_uM
}

## ingested input (mg)
IngDose = 1.0; 
## Molecular weight (g/mole)
MW = 100;
## Absorption fraction (-)
Fgutabs = 1.0; #
## Absorption rate constant (/h)
kgutabs = 1.0; #
## Elimination rate constants (/h)
kelim = 1.0;
## Distribution volumes (L)
Vdist = 1.0;

CalcOutputs { 
  A = (IngDose * Fgutabs * kgutabs)/(Vdist * (kgutabs - kelim));
  Conc = A * exp(-kelim * t) - A * exp(-kgutabs * t);
  Conc_uM = Conc / MW * 1000;
}

End.
```

- Compartment model (R)

```r
pbtk1cpt <- function(t, state, parameters) {
  with(as.list(c(state, parameters)), {
    
    dAgutlument = - kgutabs * Agutlument
    dAcompartment = kgutabs * Agutlument - ke * Acompartment
    dAmetabolized = ke * Acompartment
    
    Ccompartment = Acompartment / vdist * BW;
    
    list(c(dAgutlument, dAcompartment, dAmetabolized), 
         "Ccompartment" = Ccompartment) 
  })
}
```

- Compartment model (MCSim)


```
States  = { 
  A_rest, 
  A_elim
};  # Quantity in central compartment (mg)

Inputs = { 
  Oral_input
}; # Drug input (mg)

Outputs = {
  C_rest, (mg/l)
  C_rest_uM, (uM)
};  # Concentration in central compartment (uM)

# Oral input modeling
Absdose;
IngDose    = 1.0; # ingested input (mg)
Fgutabs    = 1.0; #
Period     = 0.0; # period of the exposure/no exposure cycle (h)
Tlag       = 0.0; # Absorption lagtime (h)
kgutabs    = 0.1; # Intestinal absortion rate (/h)
Oral_input = PerExp (Absdose, Period, Tlag, kgutabs);

# Molecular weight (g/mole)
MW = 100;
# Distribution volumes (L)
Vdist  = 1;
# Elimination rate constants (/h)
kelim = 1;

Initialize{ Absdose = IngDose * Fgutabs; }

Dynamics { 
  dt (A_rest) = kgutabs * Oral_input - kelim * A_rest;
  dt (A_elim) = kelim * A_rest;
}

CalcOutputs { 
  C_rest = A_rest  / Vdist;
  C_rest_uM  = C_rest / MW * 1000; 
}

End.
```

## Task 3: Parameter setting and simulation

- Extract the chemical information from httk package

```{r}
parms <- httk::parameterize_1comp(chem.name = "theophylline")
parms
```

- Use the parameters in the developed model and conduct the simulation 
- Compare the difference between data and the model simulation result (Cmax, Tmax)

R

```{r}
MW <- parms$MW
Fgutabs <- parms$Fgutabs * parms$hepatic.bioavailability
kgutabs <- parms$kgutabs
kelim <- parms$kelim
Vdist <- parms$Vdist
```


```{r}
dose1 <- subset(Theoph, Subject == 1) %>% summarise(dose = mean(Dose))
t1 <- subset(Theoph, Subject == 1) %>% select(Time)
out1 <- ffpk(D = dose1$dose, Fa = Fgutabs, ka = kgutabs, ke = kelim, V = Vdist, t=t1$Time)
out1
```


```{r}
conc1 <- subset(Theoph, Subject == 1) %>% select(conc)
plot(t1$Time, conc1$conc)
lines(t1$Time, out1)

```



```{r}
data.frame(t1, out1)
```


MCSim


```
Integrate (Lsodes, 1e-8, 1e-8, 1);

MW         = 180.167;  # moleculor mass (g/mol)
IngDose    = 4.02;     # ingested dose (mg)
Period     = 48;       # period of the exposure/no exposure cycle (h)
Fgutabs    = 0.9142;   # bioavailability (-) 
kgutabs    = 2.18;     # absortion rate (/h)
kelim      = 0.2654;   # elimination rate constant (/h)
Vdist      = 0.7802;   # volumes (L)

Simulation {
  Print (C_rest 0.00   0.25   0.57   1.12   2.02   3.82   5.10   7.03   9.05  12.12  24.37);
}
End.
```

```{r}
mcsim(model = "models/pbtk1cpt.model", input = "inputs/pbtk1cpt.in")
```


```{r}
read.delim("sim.out")
```

```{r}
read.delim("sim.out", skip = 1)
```


```{r}
out <- mcsim(model = "models/pbtk1cpt.model", input = "inputs/pbtk1cpt.in")
out
```

```{r}
plot(t1$Time, conc1$conc)
lines(out$Time, out$Conc)
```

## Task 4: Developing the PBPK model

- Instead of simple PK model, in this exercise we want to apply the well developed PBPK model for 1,3 butadiene.

- First, reproduce the simulation result from the published paper*.

Inputs

```{r}
C_inh <- approxfun(x = c(0, 120), y=c(10,0), method = "constant", f = 0, rule = 2) 
```

```{r}
plot(C_inh(1:300), type="l", xlab = "Time (min)", ylab = "Butadiene inhaled concentration (ppm)")
```

Parameters and outputs 

```{r}
parameters <- c("BDM" = 73,            # Body mass (kg)
                "Height" = 1.6,        # Body height (m)
                "Age" = 40,            # in years
                "Sex" = 1,             # code 1 is male, 2 is female
                "Flow_pul" = 5,        # Pulmonary ventilation rate (L/min)
                "Pct_Deadspace" = 0.7, # Fraction of pulmonary deadspace
                "Vent_Perf" = 1.14,    # Ventilation over perfusion ratio
                "Pct_LBDM_wp" = 0.2,   # wp tissue as fraction of lean mass
                "Pct_Flow_fat" = 0.1,  # Fraction of cardiac output to fat
                "Pct_Flow_pp" = 0.35,  # ~ to pp
                "PC_art" = 2,          # Blood/air partition coefficient
                "PC_fat" = 22,         # Fat/blood ~
                "PC_wp" = 0.8,         # wp/blood ~
                "PC_pp" = 0.8,         # pp/blood ~
                "Kmetwp" = 0.25)       # Rate constant for metabolism
```

```{r}
y <- c("Q_fat" = 0, # Quantity of butadiene in fat (mg)
       "Q_wp" = 0,  # ~ in well-perfused (mg)
       "Q_pp" = 0,  # ~ in poorly-perfused (mg)
       "Q_met" = 0) # ~ metabolized (mg)
```



**Model structure**

```r
# Define the model equations
bd.model <- function(t, y, parameters) {
  with (as.list(y), {
    with (as.list(parameters), {
      
      # Define constants

      # Calculate flow and volumes
      
      # Calculate the tissue, blood, and air

      # Differentials for quantities

      # The function bd.model must return at least the derivatives
      list(c(dQ_fat, dQ_wp, dQ_pp, dQ_met), # derivatives
           c("C_ven" = C_ven, "C_art" = C_art)) # extra outputs
           
    }) # end with parameters
  }) # end with y
} # end bd.model
```

**Constants**

```r
# Known constants
Height = 1.6                            # use to calculate fraction of body fat
Age = 40                                # use to calculate fraction of body fat
Sex = 1                                 # use to calculate fraction of body fat
MW_bu = 54.0914                         # butadiene molecular weight (in grams)
ppm_per_mM = 24450                       # ppm to mM under normal conditions
ppm_per_mg_per_l = ppm_per_mM / MW_bu
mg_per_l_per_ppm = 1 / ppm_per_mg_per_l

```



**Air and blood flow**
```r
# Calculate Flow_alv from total pulmonary flow
Flow_alv = Flow_pul * (1 - Pct_Deadspace)
      
# Calculate total blood flow from Flow_alv and the V/P ratio
Flow_tot = Flow_alv / Vent_Perf
      
# Calculate fraction of body fat
Pct_BDM_fat = (1.2 * BDM / (Height * Height) - 10.8 *(2 - Sex) + 0.23 * Age - 5.4) * 0.01
      
# Calculate actual blood flows from total flow and percent flows
Flow_fat = Pct_Flow_fat * Flow_tot
Flow_pp = Pct_Flow_pp * Flow_tot
Flow_wp = Flow_tot * (1 - Pct_Flow_pp - Pct_Flow_fat)
```

**Volumes**
```r
# Actual volumes, 10% of body mass (bones…) get no butadiene
Eff_V_fat = Pct_BDM_fat * BDM
Eff_V_wp = Pct_LBDM_wp * BDM * (1 - Pct_BDM_fat)
Eff_V_pp = 0.9 * BDM - Eff_V_fat - Eff_V_wp
```

**Concentrations - tissues & blood**

```r
# Calculate the concentrations
C_fat = Q_fat / Eff_V_fat
C_wp = Q_wp / Eff_V_wp
C_pp = Q_pp / Eff_V_pp
      
# Venous blood concentrations at the organ exit
Cout_fat = C_fat / PC_fat
Cout_wp = C_wp / PC_wp
Cout_pp = C_pp / PC_pp
      
# Sum of Flow * Concentration for all compartments
dQ_ven = Flow_fat * Cout_fat + Flow_wp * Cout_wp + Flow_pp * Cout_pp
C_inh.current = C_inh(t)     # to avoid calling C_inh() twice
      
# Arterial blood concentration
# Convert input given in ppm to mg/l to match other units
C_art = (Flow_alv * C_inh.current * mg_per_l_per_ppm + dQ_ven) / (Flow_tot + Flow_alv / PC_art)
      
# Venous blood concentration (mg/L)
C_ven = dQ_ven / Flow_tot
```

**Concentrations - air**

```r
# Alveolar air concentration (mg/L)
C_alv = C_art / PC_art
      
# Exhaled air concentration (ppm)
if (C_alv <= 0) {
  C_exh = 10E-30    # avoid round off errors
} else {
  C_exh = (1 - Pct_Deadspace) * C_alv * ppm_per_mg_per_l + Pct_Deadspace * C_inh.current
}
```


**Differentials for quantities**

```r
# Quantity metabolized in liver (included in well-perfused)
dQmet_wp = Kmetwp * Q_wp
      
# Differentials for quantities
dQ_fat = Flow_fat * (C_art - Cout_fat)
dQ_wp = Flow_wp * (C_art - Cout_wp) - dQmet_wp
dQ_pp = Flow_pp * (C_art - Cout_pp)
dQ_met = dQmet_wp
```

```{r}
# Define the model equations
bd.model = function(t, y, parameters) {
  with (as.list(y), {
    with (as.list(parameters), {
      
      # Define some known constants
      Height = 1.6       # use to calculate fraction of body fat
      Age = 40           # use to calculate fraction of body fat
      Sex = 1            # use to calculate fraction of body fat
      MW_bu = 54.0914    # butadiene molecular weight (in grams)

      # Conversions from/to ppm
      ppm_per_mM = 24450 # ppm to mM under normal conditions
      ppm_per_mg_per_l = ppm_per_mM / MW_bu
      mg_per_l_per_ppm = 1 / ppm_per_mg_per_l
      
      # Calculate Flow_alv from total pulmonary flow
      Flow_alv = Flow_pul * (1 - Pct_Deadspace)
      
      # Calculate total blood flow from Flow_alv and the V/P ratio
      Flow_tot = Flow_alv / Vent_Perf
      
      # Calculate fraction of body fat
      Pct_BDM_fat = (1.2 * BDM / (Height * Height) - 10.8
                     *(2 - Sex) + 0.23 * Age - 5.4) * 0.01
      
      # Actual volumes, 10% of body mass (bones…) get no butadiene
      Eff_V_fat = Pct_BDM_fat * BDM
      Eff_V_wp = Pct_LBDM_wp * BDM * (1 - Pct_BDM_fat)
      Eff_V_pp = 0.9 * BDM - Eff_V_fat - Eff_V_wp
      
      # Calculate actual blood flows from total flow and percent flows
      Flow_fat = Pct_Flow_fat * Flow_tot
      Flow_pp = Pct_Flow_pp * Flow_tot
      Flow_wp = Flow_tot * (1 - Pct_Flow_pp - Pct_Flow_fat)
      
      # Calculate the concentrations
      C_fat = Q_fat / Eff_V_fat
      C_wp = Q_wp / Eff_V_wp
      C_pp = Q_pp / Eff_V_pp
      
      # Venous blood concentrations at the organ exit
      Cout_fat = C_fat / PC_fat
      Cout_wp = C_wp / PC_wp
      Cout_pp = C_pp / PC_pp
      
      # Sum of Flow * Concentration for all compartments
      dQ_ven = Flow_fat * Cout_fat + Flow_wp * Cout_wp + Flow_pp * Cout_pp
      C_inh.current = C_inh(t) # to avoid calling C_inh() twice
      
      # Arterial blood concentration
      # Convert input given in ppm to mg/l to match other units
        C_art = (Flow_alv * C_inh.current * mg_per_l_per_ppm + dQ_ven) / (Flow_tot + Flow_alv / PC_art)
      
      # Venous blood concentration (mg/L)
      C_ven = dQ_ven / Flow_tot
      
      # Alveolar air concentration (mg/L)
      C_alv = C_art / PC_art
      
      # Exhaled air concentration (ppm)
      if (C_alv <= 0) {
        C_exh = 10E-30 # avoid round off errors
      } else {
        C_exh = (1 - Pct_Deadspace) * C_alv * ppm_per_mg_per_l + Pct_Deadspace * C_inh.current
      }
      
      # Quantity metabolized in liver (included in well-perfused)
      dQmet_wp = Kmetwp * Q_wp
      
      # Differentials for quantities
      dQ_fat = Flow_fat * (C_art - Cout_fat)
      dQ_wp = Flow_wp * (C_art - Cout_wp) - dQmet_wp
      dQ_pp = Flow_pp * (C_art - Cout_pp)
      dQ_met = dQmet_wp

      # The function bd.model must return at least the derivatives
      list(c(dQ_fat, dQ_wp, dQ_pp, dQ_met), # derivatives
           c("C_ven" = C_ven, "C_art" = C_art)) # extra outputs

    }) # end with parameters
  }) # end with y
} # end bd.model

```


```{r}
# Define the computation output times
t <- seq(from=0, to=1440, by=10)

# Solve ODE
out <- ode(times=t, func=bd.model, y=y, parms=parameters)
head(out)
```


```{r}
plot(out)
```


## Task 5: Apply the PBPK model

- Based on the OSHA permissible exposure limit (PEL), the time-weighted average is 1 ppm. If a worker is under the exposure for a long time, what is the estimated blood concentration.

```{r}
t_exposure <- 43200 # 30 days
C_inh <- approxfun(x = c(0, t_exposure), y=c(10,0), method = "constant", f = 0, rule = 2) 
```

```{r}
plot(C_inh(1:t_exposure), type="l", xlab = "Time (min)", ylab = "Butadiene inhaled concentration (ppm)")
```


```{r}
t <- seq(from=0, to=t_exposure, by=100)
out <- ode(times=t, func=bd.model, y=y, parms=parameters)
```


```{r}
tail(out, 10)
```


```{r}
plot(out)
```

## Session info

```{r}
sessionInfo()
```

## Reference

Bois F.Y. 2013. [Bayesian Inference](https://link.springer.com/protocol/10.1007/978-1-62703-059-5_25#Bib1). In: Reisfeld B., Mayeno A. (eds) Computational Toxicology. Methods in Molecular Biology (Methods and Protocols), vol 930. Humana Press, Totowa, NJ

Bois F.Y., Brochot C. (2016) [Modeling Pharmacokinetics](https://link.springer.com/protocol/10.1007%2F978-1-4939-3609-0_3). In: Benfenati E. (eds) In Silico Methods for Predicting Drug Toxicity. Methods in Molecular Biology, vol 1425. Humana Press, New York, NY

Pearce, R.G., Setzer, R.W., Strope, C.L., Wambaugh, J.F. and Sipes, N.S., 2017. [httk: R package for high-throughput toxicokinetics](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6134854/). Journal of statistical software, 79(4), p.1.

Soetaert, K.E., Petzoldt, T. and Setzer, R.W., 2010. [Solving differential equations in R: package deSolve](https://www.jstatsoft.org/article/view/v033i09). Journal of statistical software, 33.
